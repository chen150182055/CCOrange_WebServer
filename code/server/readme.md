# 利用IO复用技术Epoll与线程池实现多线程的Reactor高并发模型

I/O多路复用（I/O multiplexing）是一种高效的I/O处理方式，可以让单个线程同时处理多个I/O操作。常用的I/O多路复用的API有select、poll和epoll。

I/O多路复用的基本原理是，通过调用操作系统提供的I/O复用函数（select、poll或epoll），把多个I/O事件注册到同一个内核事件表中，然后阻塞等待这些事件中的任意一个事件就绪，一旦有事件就绪，就返回就绪事件的相关信息（如文件描述符）。这样，程序就可以在单个线程中同时处理多个I/O操作。

### I/O多路复用的主要优点包括：

1. 节省资源：使用单个线程处理多个I/O操作，避免了创建多个线程的开销和线程上下文切换的开销。
2. 提高效率：当存在大量的I/O事件时，使用I/O多路复用可以减少系统调用次数，提高效率。
3. 可移植性：I/O多路复用是跨平台的，因为不同操作系统都提供了相应的I/O复用函数。

### I/O多路复用的缺点是：

1. 对程序员要求高：需要对文件描述符进行状态判断，以区分哪些文件描述符是可读、可写或异常的。
2. 调试困难：由于多个I/O事件被注册到同一个内核事件表中，因此调试时需要跟踪多个事件，会带来一定的困难。

---

### 线程池

线程池是一种常用的并发编程技术，通过预先创建一定数量的线程并将任务加入到一个任务队列中，使得每个线程可以从队列中获取任务并执行。这种技术可以有效地控制系统中线程的数量，避免过多的线程创建和销毁的开销，提高系统的性能和稳定性。

线程池的实现通常包括以下几个部分：

1. 任务队列：用于存放任务，一般采用先进先出的队列结构。
2. 线程池管理器：用于管理线程池，包括线程的创建和销毁，任务的添加和分配，线程池的状态管理等。
3. 工作线程：用于处理任务的线程，从任务队列中获取任务并执行。

线程池的实现可以参考如下步骤：

1. 创建一个固定数量的线程池，每个线程在空闲状态下会不断地从任务队列中获取任务并执行，直到任务队列为空或者线程池关闭。
2. 创建一个任务队列，任务队列存放任务的指针或者任务对象。
3. 向任务队列中添加任务，线程池中的线程会自动从任务队列中获取任务并执行。
4. 线程池关闭时，需要将任务队列中的所有任务执行完毕后再退出。

线程池的实现可以使用 C++11 中的 std::thread，std::mutex，std::condition\_variable 等标准库实现，也可以使用 POSIX 线程库或者 Windows 线程库等系统级的 API 实现。其中，C++11 的 std::future 和 std::promise 可以用于获取异步执行结果，提高程序的并发性能

---

## 在Linux下，有以下几种并发模型：

1. 进程并发模型：通过创建多个进程实现并发处理。优点是进程间互不干扰，缺点是进程切换开销大，需要进程间通信（IPC）。
2. 多线程并发模型：通过创建多个线程实现并发处理。优点是线程间切换开销较小，易于共享数据，缺点是线程间共享内存需要考虑同步问题。
3. 半同步/半异步线程池并发模型：通过线程池和同步/异步两种方式实现并发处理。线程池中的线程负责处理 I/O 事件的异步调度和非 I/O 事件的同步处理。
4. 事件驱动并发模型：通过事件循环实现并发处理。事件循环负责监听所有的 I/O 事件，当事件发生时，调用对应的回调函数进行处理。事件驱动模型的优点是高并发、低延迟、低资源消耗，缺点是编程难度较高

---

## 两种高效的事件处理模式Reactor和Proactor

> 事件处理模式是一种常用的编程模式，用于编写高效、响应快速的事件驱动程序。事件处理模式的基本思想是：程序通过等待事件的到来，而不是通过轮询来获取事件；当事件发生时，程序会采取相应的行动，并将处理结果发送给感兴趣的对象
>
> 常见的事件处理模式包括以下几种
>
> 1.Reactor
>
> Reactor模式是基于同步I/O的事件处理模式
>
> 在该模式中，程序将一个或多个I/O对象注册到Reactor中，并在事件到达时执行相应的回调函数
>
> 2.Proactor
>
> Proactor模式是基于异步I/O的事件处理模式
>
> 在该模式中，程序将一个或多个I/O对象注册到Proactor中，并在I/O操作完成时调用相应的回调函数
>
> 3.Actor
>
> Actor模式是一种基于消息传递的事件处理模式
>
> 在该模式中，每个Actor对象都是一个独立的实体，具有自己的状态和行为，并通过消息传递来与其他Actor对象通信
>
> 4.Future/Promise
>
> Future/Promise模式是一种基于异步编程的事件处理模式
>
> 在该模式中，程序通过Future对象表示尚未完成的异步操作的结果，并使用Promise对象来设置异步操作的结果
>
> 总之，事件处理模式是一种非常有用的编程模式，可以提高程序的响应速度和并发能力。具体选择哪种事件处理模式，要根据应用场景和需求来决定

### Reactor

Reactor是一种基于事件驱动的编程模式，用于实现高并发、高性能的网络服务器应用程序。在Reactor模式中，程序首先使用I/O多路复用技术（如select、poll、epoll等）将所有的I/O事件注册到事件处理器中，然后事件处理器会监听这些事件，并根据事件类型选择相应的事件处理器处理事件。一旦有事件发生，事件处理器会从事件队列中取出相应的事件，并调用相应的事件处理器对事件进行处理，处理完后将处理结果返回给事件处理器，然后事件处理器将处理结果返回给用户

---

### Proactor

在Proactor模式中，程序首先将异步操作注册到操作系统的异步操作队列中，然后通过I/O多路复用技术等方式监听异步操作队列。一旦有异步操作完成，操作系统会通知应用程序，应用程序再通过相应的事件处理器处理异步操作结果。Proactor模式通常适用于需要大量异步I/O操作的应用场景，例如文件服务器、数据库服务器等

Proactor是一种基于事件驱动的编程模型，用于实现异步I/O操作。与Reactor模型不同，Proactor是由操作系统内核主动发起I/O请求，当I/O操作完成时通知应用程序。

在Proactor模型中，应用程序需要做的是向内核注册异步I/O操作，然后等待内核通知I/O操作的完成，而不需要像Reactor那样等待I/O事件的到来。当I/O操作完成后，内核会通知应用程序，并将I/O操作的结果存放在一个缓冲区中，应用程序再从缓冲区中读取I/O操作的结果。

Proactor模型的优点是可以避免I/O操作的阻塞，提高系统的吞吐量。同时，由于I/O操作是由内核发起的，可以减少系统调用的次数，提高系统性能。在高并发、高吞吐量的应用场景中，Proactor模型通常比Reactor模型更加适用
